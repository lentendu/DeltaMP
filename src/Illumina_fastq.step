# 
# DeltaMP, a flexible, reproducible and resource efficient metabarcoding amplicon pipeline for HPC
# Copyright (C) 2018 Guillaume Lentendu, Christina Wei√übecker, Anna Heintz-Buschart, Tesfaye Wubet
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

# Define Variables
while read var val; do unset $var ; if [[ $val == "(["* ]]; then declare -A $var="`echo $val | sed 's/].\"/]=\"/g'`" ; else declare $var="$val" ; fi ; done < config/env.txt
. $BIN/check_previous_step

# load modules
module load DeltaMP/${VERSION[DELTAMP]}

# Library to analyse
read LIB_NAME FWD_SUF RVS_SUF <<<`sed -n ${ARRAY_TASK}'p' config/lib2.list`
FWD_LIB=${LIB_NAME}${FWD_SUF/.$RAW_EXT.*/}
RVS_LIB=${LIB_NAME}${RVS_SUF/.$RAW_EXT.*/}
cd libraries

# Primer clipping
if [ $CLIPPING == "yes" ]
then
	FWD_RC=$(echo ">fwd#$FWD" | tr "#" "\n" | vsearch --quiet --fastx_revcomp - --fastaout - | grep -v ">")
	RVS_RC=$(echo ">rvs#$RVS" | tr "#" "\n" | vsearch --quiet --fastx_revcomp - --fastaout - | grep -v ">")
	DISS=`awk -v F=${#FWD} -v R=${#RVS} -v D=$PDIFFS 'BEGIN{DISS=D/F;if(D/R>DISS){DISS=D/R};printf "%.2g\n", DISS}'`
	# cutadapt
	# in forward primer direction (and conversely for reverse library)
	cutadapt -a $FWD...$RVS_RC -A $RVS...$FWD_RC -e $DISS --no-indels --untrimmed-output=fastq/$FWD_LIB.fwd_unt.fastq --untrimmed-paired-output=fastq/$RVS_LIB.fwd_unt.fastq -o fastq/$FWD_LIB.fwd.fastq -p fastq/$RVS_LIB.fwd.fastq $FWD_LIB.fastq $RVS_LIB.fastq > fastq/log.cutadapt.$LIB_NAME.fwd.txt
	# in reverse primer direction and reverse complement (if not empty)
	cutadapt -a $RVS...$FWD_RC -A $FWD...$RVS_RC -e $DISS --no-indels --trimmed-only -o fastq/$FWD_LIB.rvs.fastq -p fastq/$RVS_LIB.rvs.fastq fastq/$FWD_LIB.fwd_unt.fastq fastq/$RVS_LIB.fwd_unt.fastq > fastq/log.cutadapt.$LIB_NAME.rvs.txt
	if [ -s fastq/$FWD_LIB.rvs.fastq ]
	then
		vsearch --quiet --fastx_revcomp fastq/$FWD_LIB.rvs.fastq --fastqout - | cat fastq/$FWD_LIB.fwd.fastq - > fastq/$LIB_NAME.fwd.fastq
		rm fastq/$FWD_LIB.rvs.fastq fastq/$FWD_LIB.fwd.fastq fastq/$FWD_LIB.fwd_unt.fastq
	else
		mv fastq/$FWD_LIB.fwd.fastq fastq/$LIB_NAME.fwd.fastq
		rm fastq/$FWD_LIB.rvs.fastq fastq/$FWD_LIB.fwd_unt.fastq
	fi
	if [ -s fastq/$RVS_LIB.rvs.fastq ]
	then
		vsearch --quiet --fastx_revcomp fastq/$RVS_LIB.rvs.fastq --fastqout - | cat fastq/$RVS_LIB.fwd.fastq - > fastq/$LIB_NAME.rvs.fastq
		rm fastq/$RVS_LIB.rvs.fastq fastq/$RVS_LIB.fwd.fastq fastq/$RVS_LIB.fwd_unt.fastq
	else
		mv fastq/$RVS_LIB.fwd.fastq fastq/$LIB_NAME.rvs.fastq
		rm fastq/$RVS_LIB.rvs.fastq fastq/$RVS_LIB.fwd_unt.fastq
	fi
	# primer logo
	# weblogo -c classic -s large -t "$LIB_NAME: $FWD_NAME" < <(awk -v a=${#FWD} 'BEGIN{FS="\t"} NF==11{printf ">%s\n%*s\n",$1,a,$6}' raw_stat/$FWD_LIB.cutadapt | sed 's/ /N/g' )> raw_stat/weblogo.$LIB_NAME.forward.eps
	# weblogo -c classic -s large -t "$LIB_NAME: primer $RVS_NAME" < <(awk -v a=${#RVS} 'BEGIN{FS="\t"} NF==11{printf ">%s\n%*s\n",$1,a,$6}' raw_stat/$RVS_LIB.cutadapt | sed 's/ /N/g') > raw_stat/weblogo.$LIB_NAME.reverse.eps
else
	ln -s $PWD/$FWD_LIB.fastq $PWD/fastq/$LIB_NAME.fwd.fastq
	ln -s $PWD/$RVS_LIB.fastq $PWD/fastq/$LIB_NAME.rvs.fastq
fi

# Convert to fasta + qual for raw reads stat
mothur "#set.dir(input=$EXEC/libraries/fastq, output=$EXEC/libraries/fasta);
set.logfile(name=mothur.$LIB_NAME.logfile);
fastq.info(fastq=$LIB_NAME.fwd.fastq);
fastq.info(fastq=$LIB_NAME.rvs.fastq)"

awk '$0!~"^>"{sum=0;for(i=1;i<=NF;i++){sum+=$i};print int(sum/NF)}' fasta/$LIB_NAME.fwd.qual > raw_stat/$LIB_NAME.fwd.meanqual
awk '$0!~"^>"{for(i=1;i<=NF;i++){sum[i]+=$i;nb[i]+=1}}END{for(i=1;sum[i];i++){print int(sum[i]/nb[i])}}' fasta/$LIB_NAME.fwd.qual > raw_stat/$LIB_NAME.fwd.meanposqual
awk '$0!~"^>"{sum=0;for(i=1;i<=NF;i++){sum+=$i};print int(sum/NF)}' fasta/$LIB_NAME.rvs.qual > raw_stat/$LIB_NAME.rvs.meanqual
awk '$0!~"^>"{for(i=1;i<=NF;i++){sum[i]+=$i;nb[i]+=1}}END{for(i=1;sum[i];i++){print int(sum[i]/nb[i])}}' fasta/$LIB_NAME.rvs.qual > raw_stat/$LIB_NAME.rvs.meanposqual

rm fasta/$LIB_NAME.fwd.fasta fasta/$LIB_NAME.fwd.qual fasta/$LIB_NAME.rvs.fasta fasta/$LIB_NAME.rvs.qual

# list files and directories
. $BIN/list_step_files.sh

echo END



